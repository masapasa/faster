[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "dhblog",
    "section": "",
    "text": "Hello, I’m Aswin Pyakurel, Data Scientist, currently living in the french riviera. I love programming, and math and am a big fan of fast.ai. Here is where I share all the knowledge I discover along my AI journey\nYou can find me at:\n\nTwitter: https://twitter.com/aswinpy\nKaggle: https://www.kaggle.com/masapasa\nFast.ai Forum: https://forums.fast.ai/u/masapasa/summary\nLinkedIn: https://www.linkedin.com/in/aswinpyakurel/"
  },
  {
    "objectID": "captcha.html",
    "href": "captcha.html",
    "title": "Captcha or Sequence Classification (WIP)",
    "section": "",
    "text": "from fastai.vision.all import *\nimport PIL\nfrom torch.nn import CTCLoss\nfrom scipy.special import logsumexp  # log(p1 + p2) = logsumexp([log_p1, log_p2])"
  },
  {
    "objectID": "captcha.html#simple-classification-model",
    "href": "captcha.html#simple-classification-model",
    "title": "Captcha or Sequence Classification (WIP)",
    "section": "Simple Classification Model",
    "text": "Simple Classification Model\nA simple image classification is used with output dimension is: Number_of_vocab x Number_of_characters\n\nmodel = create_cnn_model(xresnet34, n_chars*5)\n\n\ncrit = LabelSmoothingCrossEntropyFlat()\n\n\ndef loss_captcha(output, target):\n    output = output.view(-1, 5, n_chars)\n    return crit(output, target)\n\n\ndef char_accu(inp, targ, axis=-1):\n    inps = inp.reshape(-1, 5, n_chars)\n    pred = inps.argmax(dim=-1)\n    return (pred == targ).sum()/(pred.shape[0]*pred.shape[1])\n\n\ndef captcha_accu(inp, targ, axis=-1):\n    inps = inp.reshape(-1, 5, n_chars)\n    pred = inps.argmax(dim=-1)\n    return ((pred == targ).all(axis=1)).sum()/targ.shape[0]\n\n\nlearn = Learner(dls, model, loss_captcha, metrics=[char_accu, captcha_accu])\n\n\nlearn.fit_one_cycle(40, 3e-3)\n\n\n\n\n\n\n\n  \n    \n      epoch\n      train_loss\n      valid_loss\n      char_accu\n      captcha_accu\n      time\n    \n  \n  \n    \n      0\n      4.476278\n      3.333658\n      0.065385\n      0.000000\n      00:30\n    \n    \n      1\n      4.417804\n      3.126414\n      0.071154\n      0.000000\n      00:29\n    \n    \n      2\n      4.304584\n      3.232960\n      0.058654\n      0.000000\n      00:29\n    \n    \n      3\n      4.187447\n      3.362142\n      0.062500\n      0.000000\n      00:30\n    \n    \n      4\n      4.027558\n      3.753680\n      0.091346\n      0.000000\n      00:30\n    \n    \n      5\n      3.866274\n      4.317540\n      0.092308\n      0.000000\n      00:30\n    \n    \n      6\n      3.705276\n      3.727203\n      0.130769\n      0.000000\n      00:30\n    \n    \n      7\n      3.543381\n      3.895546\n      0.121154\n      0.000000\n      00:30\n    \n    \n      8\n      3.367218\n      5.266652\n      0.099038\n      0.000000\n      00:30\n    \n    \n      9\n      3.192778\n      3.641559\n      0.182692\n      0.000000\n      00:30\n    \n    \n      10\n      3.016066\n      3.658565\n      0.169231\n      0.000000\n      00:30\n    \n    \n      11\n      2.840049\n      4.248789\n      0.186538\n      0.000000\n      00:30\n    \n    \n      12\n      2.668165\n      4.148201\n      0.192308\n      0.000000\n      00:30\n    \n    \n      13\n      2.500451\n      3.241827\n      0.261538\n      0.004808\n      00:29\n    \n    \n      14\n      2.345507\n      2.236456\n      0.424038\n      0.004808\n      00:30\n    \n    \n      15\n      2.201324\n      2.046680\n      0.468269\n      0.028846\n      00:29\n    \n    \n      16\n      2.065930\n      2.029218\n      0.500962\n      0.033654\n      00:30\n    \n    \n      17\n      1.944293\n      1.877636\n      0.531731\n      0.057692\n      00:30\n    \n    \n      18\n      1.833889\n      1.612115\n      0.605769\n      0.086538\n      00:29\n    \n    \n      19\n      1.732575\n      1.713561\n      0.594231\n      0.096154\n      00:30\n    \n    \n      20\n      1.639566\n      1.641400\n      0.601923\n      0.110577\n      00:30\n    \n    \n      21\n      1.557264\n      1.428647\n      0.692308\n      0.192308\n      00:30\n    \n    \n      22\n      1.483890\n      1.424564\n      0.678846\n      0.182692\n      00:30\n    \n    \n      23\n      1.417021\n      1.300680\n      0.751923\n      0.283654\n      00:30\n    \n    \n      24\n      1.356270\n      1.326570\n      0.732692\n      0.240385\n      00:29\n    \n    \n      25\n      1.301427\n      1.333500\n      0.746154\n      0.254808\n      00:30\n    \n    \n      26\n      1.251688\n      1.252823\n      0.782692\n      0.331731\n      00:29\n    \n    \n      27\n      1.208397\n      1.180259\n      0.810577\n      0.365385\n      00:30\n    \n    \n      28\n      1.168011\n      1.156677\n      0.826923\n      0.437500\n      00:29\n    \n    \n      29\n      1.131522\n      1.161403\n      0.816346\n      0.399038\n      00:29\n    \n    \n      30\n      1.099192\n      1.141058\n      0.814423\n      0.403846\n      00:29\n    \n    \n      31\n      1.069991\n      1.125866\n      0.836538\n      0.471154\n      00:30\n    \n    \n      32\n      1.043716\n      1.110983\n      0.838462\n      0.490385\n      00:30\n    \n    \n      33\n      1.020709\n      1.092527\n      0.848077\n      0.514423\n      00:30\n    \n    \n      34\n      0.999525\n      1.091171\n      0.853846\n      0.504808\n      00:29\n    \n    \n      35\n      0.981022\n      1.080948\n      0.863462\n      0.524038\n      00:29\n    \n    \n      36\n      0.964225\n      1.082140\n      0.853846\n      0.495192\n      00:29\n    \n    \n      37\n      0.948947\n      1.076262\n      0.857692\n      0.528846\n      00:29\n    \n    \n      38\n      0.935679\n      1.073239\n      0.856731\n      0.519231\n      00:29\n    \n    \n      39\n      0.923326\n      1.071550\n      0.858654\n      0.543269\n      00:29\n    \n  \n\n\n\n\nlearn.recorder.plot_loss()\n\n\n\n\n\nNo AvgPool\nIn the model used above, between the body and head, there is an AvgPool2d layer, which blurs all essential spatial information. So let’s remove it and create our own head\n\n\n\nimage.png\n\n\n\nbody = create_body(xresnet34)\n\n\nhead = nn.Sequential(\n    Flatten(),\n    nn.ReLU(),\n    nn.Dropout(0.5),\n    nn.Linear(7168,1000),\n    nn.ReLU(),\n    nn.BatchNorm1d(1000),\n    nn.Dropout(0.5),\n    nn.Linear(1000,95),\n)\n\n\nmodel = nn.Sequential(body, head)\n\n\nlearn = Learner(dls, model, loss_captcha, metrics=[char_accu, captcha_accu])\n\n\n# learn.lr_find()\n\n\nlearn.fit_one_cycle(40, 3e-3)\n\n\n\n\n\n\n\n  \n    \n      epoch\n      train_loss\n      valid_loss\n      char_accu\n      captcha_accu\n      time\n    \n  \n  \n    \n      0\n      3.191548\n      2.941001\n      0.076923\n      0.000000\n      00:29\n    \n    \n      1\n      3.075782\n      2.899808\n      0.126923\n      0.000000\n      00:29\n    \n    \n      2\n      2.906533\n      2.830948\n      0.147115\n      0.000000\n      00:29\n    \n    \n      3\n      2.710024\n      2.763503\n      0.163462\n      0.000000\n      00:29\n    \n    \n      4\n      2.498606\n      2.544354\n      0.270192\n      0.000000\n      00:29\n    \n    \n      5\n      2.277901\n      2.081050\n      0.442308\n      0.000000\n      00:29\n    \n    \n      6\n      2.070913\n      1.772311\n      0.565385\n      0.076923\n      00:29\n    \n    \n      7\n      1.886266\n      1.783266\n      0.543269\n      0.067308\n      00:29\n    \n    \n      8\n      1.730296\n      1.627859\n      0.595192\n      0.072115\n      00:29\n    \n    \n      9\n      1.598513\n      1.726345\n      0.553846\n      0.052885\n      00:29\n    \n    \n      10\n      1.487451\n      1.446010\n      0.688462\n      0.149038\n      00:29\n    \n    \n      11\n      1.393924\n      1.350629\n      0.741346\n      0.235577\n      00:30\n    \n    \n      12\n      1.316039\n      1.279284\n      0.764423\n      0.317308\n      00:30\n    \n    \n      13\n      1.247274\n      1.165796\n      0.796154\n      0.341346\n      00:29\n    \n    \n      14\n      1.188182\n      1.245245\n      0.777885\n      0.298077\n      00:30\n    \n    \n      15\n      1.136491\n      1.179183\n      0.816346\n      0.394231\n      00:30\n    \n    \n      16\n      1.091255\n      1.050491\n      0.873077\n      0.519231\n      00:30\n    \n    \n      17\n      1.050464\n      1.062263\n      0.862500\n      0.538462\n      00:30\n    \n    \n      18\n      1.014761\n      0.979492\n      0.893269\n      0.625000\n      00:30\n    \n    \n      19\n      0.982404\n      1.006078\n      0.894231\n      0.615385\n      00:30\n    \n    \n      20\n      0.952830\n      0.982500\n      0.900000\n      0.658654\n      00:30\n    \n    \n      21\n      0.927115\n      0.914533\n      0.928846\n      0.745192\n      00:29\n    \n    \n      22\n      0.903571\n      0.955804\n      0.916346\n      0.716346\n      00:30\n    \n    \n      23\n      0.882480\n      0.912319\n      0.934615\n      0.759615\n      00:30\n    \n    \n      24\n      0.863520\n      0.921165\n      0.927885\n      0.725962\n      00:29\n    \n    \n      25\n      0.846013\n      0.867773\n      0.935577\n      0.788462\n      00:29\n    \n    \n      26\n      0.830049\n      0.867557\n      0.937500\n      0.783654\n      00:30\n    \n    \n      27\n      0.815565\n      0.860243\n      0.943269\n      0.817308\n      00:30\n    \n    \n      28\n      0.802556\n      0.856743\n      0.947115\n      0.822115\n      00:30\n    \n    \n      29\n      0.790769\n      0.859355\n      0.947115\n      0.807692\n      00:30\n    \n    \n      30\n      0.779875\n      0.854335\n      0.942308\n      0.798077\n      00:30\n    \n    \n      31\n      0.770362\n      0.846707\n      0.949038\n      0.817308\n      00:30\n    \n    \n      32\n      0.761172\n      0.840953\n      0.950000\n      0.817308\n      00:30\n    \n    \n      33\n      0.752919\n      0.836481\n      0.948077\n      0.817308\n      00:30\n    \n    \n      34\n      0.745560\n      0.827576\n      0.949038\n      0.826923\n      00:30\n    \n    \n      35\n      0.739381\n      0.824142\n      0.951923\n      0.831731\n      00:30\n    \n    \n      36\n      0.733570\n      0.819511\n      0.954808\n      0.836538\n      00:30\n    \n    \n      37\n      0.728176\n      0.817993\n      0.952885\n      0.831731\n      00:30\n    \n    \n      38\n      0.723199\n      0.819822\n      0.953846\n      0.831731\n      00:30\n    \n    \n      39\n      0.718606\n      0.820445\n      0.948077\n      0.812500\n      00:29\n    \n  \n\n\n\n\nlearn.recorder.plot_loss()\n\n\n\n\n\nlearn.unfreeze()\n\n\nlearn.lr_find()\n\n\n\n\n\n\n\n\nSuggestedLRs(valley=0.0002754228771664202)\n\n\n\n\n\n\nlearn.fit_one_cycle(4, lr_max=slice(1e-6,1e-4))\n\n\n\n\n\n\n\n  \n    \n      epoch\n      train_loss\n      valid_loss\n      char_accu\n      captcha_accu\n      time\n    \n  \n  \n    \n      0\n      0.684843\n      0.818710\n      0.951923\n      0.831731\n      00:30\n    \n    \n      1\n      0.683118\n      0.822131\n      0.948077\n      0.822115\n      00:30\n    \n    \n      2\n      0.684270\n      0.820947\n      0.950000\n      0.826923\n      00:30\n    \n    \n      3\n      0.684729\n      0.818542\n      0.950962\n      0.831731\n      00:29\n    \n  \n\n\n\nAs expected, the accuracy is much better in this version."
  },
  {
    "objectID": "captcha.html#crnn-coming-soon",
    "href": "captcha.html#crnn-coming-soon",
    "title": "Captcha or Sequence Classification (WIP)",
    "section": "CRNN (Coming soon)",
    "text": "CRNN (Coming soon)"
  },
  {
    "objectID": "ssd_base.html",
    "href": "ssd_base.html",
    "title": "Object Detection - Single Shot Detector for fastai V2",
    "section": "",
    "text": "Object Detection\nRecently, I had a project that needs to modify an Object Detection Architecture. However, when I searched for related repositories, I found it quite difficult to understand. We have a lot of libraries for use out of the box but hard to make changes to the source code.\nThis blog is the implementation of Single Shot Detector Architecture using fast.ai in literate programming style so the readers can follow and run each line of code themselves in case needed to deepen their knowledge.\nThe original idea was taken from the fastai 2018 course. Readers are recommended to watch this lecture. 2018 Lecture\nSome useful notes taken by students: - Cedrick Note - Francesco Note\nDataset used: Pascal 2017\nWhat we can learn from this notebook:"
  },
  {
    "objectID": "ssd_base.html#object-detection-dataloaders",
    "href": "ssd_base.html#object-detection-dataloaders",
    "title": "Object Detection - Single Shot Detector for fastai V2",
    "section": "Object Detection Dataloaders",
    "text": "Object Detection Dataloaders\nFor objection detection, you have:\n\n1 independent variable (X): Image\n2 dependents variables (Ys): Bounding box and Class\n\nIn this part, we will use fastai DataBlock to build Object Detection Dataloaders. The idea is from each image file name, we will have:\n\nAn Image\nBounding Boxes getting from the annotations file\nLabels correspond to each bounding box\n\n\n\n\n\n\n\nNote\n\n\n\n\nZero padding: Each image have a different number of objects. Then, to make it possible to gather multiple images to one batch, the number of bounding boxes per image is the maximum in that batch (the padding value by default is 0) bb_pad\nBackground class: In Object Detection, we need to have a class that represents the background. fastai do it automatically for you by adding #na# at index 0\nThe coordinates of bounding box is rescaled to ~ -1 -> 1 in fastai/vision/core.py _scale_pnts\n\n\n\n( Check out some outputs below for details )\n\n\n\nList of Files to Data\n\n\n\npath = untar_data(URLs.PASCAL_2007)\n\n\npath.ls()\n\n(#8) [Path('/home/ubuntu/.fastai/data/pascal_2007/train.json'),Path('/home/ubuntu/.fastai/data/pascal_2007/test.json'),Path('/home/ubuntu/.fastai/data/pascal_2007/test'),Path('/home/ubuntu/.fastai/data/pascal_2007/train.csv'),Path('/home/ubuntu/.fastai/data/pascal_2007/segmentation'),Path('/home/ubuntu/.fastai/data/pascal_2007/valid.json'),Path('/home/ubuntu/.fastai/data/pascal_2007/train'),Path('/home/ubuntu/.fastai/data/pascal_2007/test.csv')]\n\n\n\nimgs, lbl_bbox = get_annotations(path/'train.json')\n\n\nimgs[0], lbl_bbox[0]\n\n('000012.jpg', ([[155, 96, 351, 270]], ['car']))\n\n\n\nimg2bbox = dict(zip(imgs, lbl_bbox))\n\n\nfirst = {k: img2bbox[k] for k in list(img2bbox)[:1]}; first\n\n{'000012.jpg': ([[155, 96, 351, 270]], ['car'])}\n\n\n\ngetters = [lambda o: path/'train'/o, lambda o: img2bbox[o][0], lambda o: img2bbox[o][1]]\n\n\nitem_tfms = [Resize(224, method='squish'),]\nbatch_tfms = [Rotate(), Flip(), Dihedral()]\n\n\npascal = DataBlock(blocks=(ImageBlock, BBoxBlock, BBoxLblBlock),\n                 splitter=RandomSplitter(),\n                 getters=getters,\n                 item_tfms=item_tfms,\n                 batch_tfms=batch_tfms,\n                 n_inp=1)\n\n\ndls = pascal.dataloaders(imgs, bs = 128)\n\n\n\n\n\n\n\nNote\n\n\n\n#na# is the background class as defined in BBoxLblBlock\n\n\n\ndls.vocab\n\n['#na#', 'aeroplane', 'bicycle', 'bird', 'boat', 'bottle', 'bus', 'car', 'cat', 'chair', 'cow', 'diningtable', 'dog', 'horse', 'motorbike', 'person', 'pottedplant', 'sheep', 'sofa', 'train', 'tvmonitor']\n\n\n\nlen(dls.vocab)\n\n21\n\n\n\ndls.show_batch()\n\n\n\n\n\none_batch = dls.one_batch()\n\n\n\n\n\n\n\nNote\n\n\n\nThe coordinates of boudning box is rescaled to ~ -1 -> 1 in fastai/vision/core.py\n\n\n\none_batch[1][0][0]\n\nTensorBBox([-0.0440, -0.2171,  0.2200,  0.5046], device='cuda:0')\n\n\n\n# Zero Padding\none_batch[2]\n\nTensorMultiCategory([[13, 15,  0,  ...,  0,  0,  0],\n                     [12, 15, 15,  ...,  0,  0,  0],\n                     [18,  5,  5,  ...,  0,  0,  0],\n                     ...,\n                     [15,  8,  8,  ...,  0,  0,  0],\n                     [ 7,  0,  0,  ...,  0,  0,  0],\n                     [ 8,  0,  0,  ...,  0,  0,  0]], device='cuda:0')"
  },
  {
    "objectID": "ssd_base.html#model-architecture",
    "href": "ssd_base.html#model-architecture",
    "title": "Object Detection - Single Shot Detector for fastai V2",
    "section": "Model Architecture",
    "text": "Model Architecture\n\n\n\nSSD Architecture\n\n\nIn a nutshell, Object Detection Model is a model that does 2 jobs at the same time:\n\na regressor with 4 outputs for bounding box\na classifier with c classes.\n\nTo handle multiple objects, here comes the grid cell. For each cell, you will have an atomic prediction for the object that dominates a part of the image ( This is the idea of the receptive field that you will see in the next part )\n\n\n\n\n\n\nMy Intuition\n\n\n\nIn Machine Learning, it is better to improve from something rather than start from scratch. You can see this in: Image Classification Architecture - Resnet with the Skip Connections, or Gradient Boosting in Tree-based Model. There is a common point in the grid-cell SSD architecture, the model will try to improve from an anchor box rather than searching through the whole image.\n\n\nWe should better leverage a well-known pretrained classification model to be used as a backbone / or body ( resnet in this tutorial ) if the object is similar to the Imagenet dataset. The head part will follow to adapt to the necessary dimension\nTo easily develop the idea - visualize and debug, we will start with a simple 4x4 grid\n\ndef flatten_conv(x,k):\n    # Flatten the 4x4 grid to dim16 vectors\n    bs,nf,gx,gy = x.size()\n    x = x.permute(0,2,3,1).contiguous()\n    return x.view(bs,-1,nf//k)\n\n\nclass OutConv(nn.Module):\n    # Output Layers for SSD-Head. Contains oconv1 for Classification and oconv2 for Detection\n    def __init__(self, k, nin, bias):\n        super().__init__()\n        self.k = k\n        self.oconv1 = nn.Conv2d(nin, (len(dls.vocab))*k, 3, padding=1)\n        self.oconv2 = nn.Conv2d(nin, 4*k, 3, padding=1)\n        self.oconv1.bias.data.zero_().add_(bias)\n        \n    def forward(self, x):\n        return [flatten_conv(self.oconv1(x), self.k),\n                flatten_conv(self.oconv2(x), self.k)]\n\n\nclass StdConv(nn.Module):\n    # Standard Convolutional layers \n    def __init__(self, nin, nout, stride=2, drop=0.1):\n        super().__init__()\n        self.conv = nn.Conv2d(nin, nout, 3, stride=stride, padding=1)\n        self.bn = nn.BatchNorm2d(nout)\n        self.drop = nn.Dropout(drop)\n        \n    def forward(self, x): return self.drop(self.bn(F.relu(self.conv(x))))\n\n\nclass SSD_Head(nn.Module):\n    def __init__(self, k, bias):\n        super().__init__()\n        self.drop = nn.Dropout(0.25)\n        self.sconv0 = StdConv(512,256, stride=1)\n        self.sconv2 = StdConv(256,256)\n        self.out = OutConv(k, 256, bias)\n        \n    def forward(self, x):\n        x = self.drop(F.relu(x))\n        x = self.sconv0(x)\n        x = self.sconv2(x)\n        return self.out(x)\n\nWe start with k = 1 which is the number of alterations for each anchor box ( we have a lot of anchor boxes later )\n\nk=1\n\n\nhead_reg4 = SSD_Head(k, -3.)\n\n\nbody = create_body(resnet34(True))\nmodel = nn.Sequential(body, head_reg4)\n\n/home/ubuntu/miniconda3/envs/blog/lib/python3.10/site-packages/torchvision/models/_utils.py:135: UserWarning: Using 'weights' as positional parameter(s) is deprecated since 0.13 and will be removed in 0.15. Please use keyword parameter(s) instead.\n  warnings.warn(\n/home/ubuntu/miniconda3/envs/blog/lib/python3.10/site-packages/torchvision/models/_utils.py:223: UserWarning: Arguments other than a weight enum or `None` for 'weights' are deprecated since 0.13 and will be removed in 0.15. The current behavior is equivalent to passing `weights=ResNet34_Weights.IMAGENET1K_V1`. You can also use `weights=ResNet34_Weights.DEFAULT` to get the most up-to-date weights.\n  warnings.warn(msg)\n\n\nTo understand and verify that everything works ok, you can take out a batch and run the model on it\n\nout0 = body(one_batch[0].cpu())\n\n\nout1 = head_reg4(out0)\n\n\nout1[0].shape, out1[1].shape\n\n(torch.Size([128, 16, 21]), torch.Size([128, 16, 4]))\n\n\nShape explanation:\n\n128: batch size\n16: number of anchor boxes\n21: number of classes\n4: number of bounding box coordinates"
  },
  {
    "objectID": "ssd_base.html#x4-anchor-boxes-and-receptive-field",
    "href": "ssd_base.html#x4-anchor-boxes-and-receptive-field",
    "title": "Object Detection - Single Shot Detector for fastai V2",
    "section": "4x4 Anchor boxes and Receptive Field",
    "text": "4x4 Anchor boxes and Receptive Field\nAs mentioned before, we will start with a 4x4 grid to better visualize the idea. The size will be normalized to [0,1]\nThe idea of why, after the Body, we use Conv2d and not Linear Layer to make a 4x4x(4+c) output dimension instead of 16x(4+c) shape is - Receptive Field. This way, each cell will have information that comes directly from the location corresponding to the anchor box. The illustration is below.\n\n\n\nSSD vs YOLO\n\n\n\n\n\nReceptive Field\n\n\n\n\n\n\n\n\nWarning\n\n\n\nBe very careful about the bounding box format when working with Object Detection. There are many different formats out there. For example:\n\npascal_voc: [x_min, y_min, x_max, y_max]\ncoco: [x_min, y_min, width, height]\nYOLO: [x_center, y_center, width, height]\n\nThe bounding box format in this tutorial is [x_min, y_min, x_max, y_max]\n\n\nCheck out Bounding Boxes Augmentation for more details:\nWe define the anchors coordinates as below\n\nanc_grid = 4 # Start with only 4x4 grid and no variation for each cell\nk = 1 # Variation of each anchor box\nanc_offset = 1/(anc_grid*2)\nanc_x = np.repeat(np.linspace(anc_offset, 1-anc_offset, anc_grid), anc_grid) # Center of anc in x\nanc_y = np.tile(np.linspace(anc_offset, 1-anc_offset, anc_grid), anc_grid) # Center f anc in y\n\n\nanc_x\n\narray([0.125, 0.125, 0.125, 0.125, 0.375, 0.375, 0.375, 0.375, 0.625,\n       0.625, 0.625, 0.625, 0.875, 0.875, 0.875, 0.875])\n\n\n\nanc_y\n\narray([0.125, 0.375, 0.625, 0.875, 0.125, 0.375, 0.625, 0.875, 0.125,\n       0.375, 0.625, 0.875, 0.125, 0.375, 0.625, 0.875])\n\n\n\nanc_ctrs = np.tile(np.stack([anc_x,anc_y], axis=1), (k,1)) # Anchor centers\nanc_sizes = np.array([[1/anc_grid,1/anc_grid] for i in range(anc_grid*anc_grid)])\n\n\nanc_ctrs\n\narray([[0.125, 0.125],\n       [0.125, 0.375],\n       [0.125, 0.625],\n       [0.125, 0.875],\n       [0.375, 0.125],\n       [0.375, 0.375],\n       [0.375, 0.625],\n       [0.375, 0.875],\n       [0.625, 0.125],\n       [0.625, 0.375],\n       [0.625, 0.625],\n       [0.625, 0.875],\n       [0.875, 0.125],\n       [0.875, 0.375],\n       [0.875, 0.625],\n       [0.875, 0.875]])\n\n\n\nanc_sizes\n\narray([[0.25, 0.25],\n       [0.25, 0.25],\n       [0.25, 0.25],\n       [0.25, 0.25],\n       [0.25, 0.25],\n       [0.25, 0.25],\n       [0.25, 0.25],\n       [0.25, 0.25],\n       [0.25, 0.25],\n       [0.25, 0.25],\n       [0.25, 0.25],\n       [0.25, 0.25],\n       [0.25, 0.25],\n       [0.25, 0.25],\n       [0.25, 0.25],\n       [0.25, 0.25]])\n\n\n\nanchors = torch.tensor(np.concatenate([anc_ctrs, anc_sizes], axis=1), requires_grad=False).cuda()\n# Coordinates with format: center_x, center_y, W, H\n\n\nanchors\n\ntensor([[0.1250, 0.1250, 0.2500, 0.2500],\n        [0.1250, 0.3750, 0.2500, 0.2500],\n        [0.1250, 0.6250, 0.2500, 0.2500],\n        [0.1250, 0.8750, 0.2500, 0.2500],\n        [0.3750, 0.1250, 0.2500, 0.2500],\n        [0.3750, 0.3750, 0.2500, 0.2500],\n        [0.3750, 0.6250, 0.2500, 0.2500],\n        [0.3750, 0.8750, 0.2500, 0.2500],\n        [0.6250, 0.1250, 0.2500, 0.2500],\n        [0.6250, 0.3750, 0.2500, 0.2500],\n        [0.6250, 0.6250, 0.2500, 0.2500],\n        [0.6250, 0.8750, 0.2500, 0.2500],\n        [0.8750, 0.1250, 0.2500, 0.2500],\n        [0.8750, 0.3750, 0.2500, 0.2500],\n        [0.8750, 0.6250, 0.2500, 0.2500],\n        [0.8750, 0.8750, 0.2500, 0.2500]], device='cuda:0',\n       dtype=torch.float64)\n\n\n\ngrid_sizes = torch.tensor(np.array([1/anc_grid]), requires_grad=False).unsqueeze(1).cuda()\n\n\ngrid_sizes\n\ntensor([[0.2500]], device='cuda:0', dtype=torch.float64)"
  },
  {
    "objectID": "ssd_base.html#visualization-utils",
    "href": "ssd_base.html#visualization-utils",
    "title": "Object Detection - Single Shot Detector for fastai V2",
    "section": "Visualization Utils",
    "text": "Visualization Utils\nIt is very helpful (to understand/ debug) when you can visualize data of every step. Many subtle tiny details happen in this Object Detection Problem. One careless implementation can lead to hours (or even days) to debug. Sometimes, you just wish that the code throws you some bugs that you can trackback.\n\n\n\n\n\n\nWarning\n\n\n\nThere are some details that you need to double check\n\nAre your ground truth bounding boxes, anchor boxes, bounding box activations are in the same scale ( -1 -> 1 or 0 -> 1 ) ?\nDo the background class is handled correctly? ( This is a bug when I develop this notebook that the old version of the fastai course set the index of background as number_of_classes but in the latest version, it is 0 )\nDo you map correctly each Anchor Box to the ground-true object? (This will be shown in the next session)\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nDon’t hesitate to take out one batch from your dataloader and verify every single detail. When I start to use fast.ai, I made a big mistake that thinking these data are already processed and we can not show things directly from there. This data is very important, it is the input of your model. It must be carefully double-checked.\n\n\nBelow we will try to plot some images from a batch with their bounding boxes and classes, to see that we did not missing anything\n\nimport matplotlib.colors as mcolors\nimport matplotlib.cm as cmx\nfrom matplotlib import patches, patheffects\n\n\ndef show_img(im, figsize=None, ax=None):\n    if not ax: fig,ax = plt.subplots(figsize=figsize)\n    ax.imshow(im)\n    ax.set_xticks(np.linspace(0, 224, 8))\n    ax.set_yticks(np.linspace(0, 224, 8))\n    ax.grid()\n    ax.set_yticklabels([])\n    ax.set_xticklabels([])\n    return ax\n\n\ndef draw_outline(o, lw):\n    o.set_path_effects([patheffects.Stroke(\n        linewidth=lw, foreground='black'), patheffects.Normal()])\n\n\ndef draw_text(ax, xy, txt, sz=14, color='white'):\n    text = ax.text(*xy, txt,\n        verticalalignment='top', color=color, fontsize=sz, weight='bold')\n    draw_outline(text, 1)\n\n\ndef draw_rect(ax, b, color='white'):\n    patch = ax.add_patch(patches.Rectangle(b[:2], *b[-2:], fill=False, edgecolor=color, lw=2))\n    draw_outline(patch, 4)\n\n\ndef bb_hw(a): return np.array([a[1],a[0],a[3]-a[1]+1,a[2]-a[0]+1])\n\n\ndef get_cmap(N):\n    color_norm  = mcolors.Normalize(vmin=0, vmax=N-1)\n    return cmx.ScalarMappable(norm=color_norm, cmap='Set3').to_rgba\n\n\nnum_colr = 12\ncmap = get_cmap(num_colr)\ncolr_list = [cmap(float(x)) for x in range(num_colr)]\n\n\ndef show_ground_truth(ax, im, bbox, clas=None, prs=None, thresh=0.3):\n    bb = [bb_hw(o) for o in bbox.reshape(-1,4)]\n    if prs is None:  prs  = [None]*len(bb)\n    if clas is None: clas = [None]*len(bb)\n    ax = show_img(im, ax=ax)\n    k=0\n    for i,(b,c,pr) in enumerate(zip(bb, clas, prs)):\n        if((b[2]>1) and (pr is None or pr > thresh)):\n            k+=1\n            draw_rect(ax, b, color=colr_list[i%num_colr])\n            txt = f'{k}: '\n            if c is not None: txt += ('bg' if c==0 else dls.vocab[c])\n            if pr is not None: txt += f' {pr:.2f}'\n            draw_text(ax, b[:2], txt, color=colr_list[i%num_colr])\n\n\ndef torch_gt(ax, ima, bbox, clas, prs=None, thresh=0.4):\n    return show_ground_truth(ax, ima, to_np((bbox*224).long()),\n         to_np(clas), to_np(prs) if prs is not None else None, thresh)\n\n\nShowing one batch\n\nidx = 5\n\n\nimg = one_batch[0][idx].permute(2,1,0).cpu()\n\n\nplt.imshow(img)\n\n<matplotlib.image.AxesImage at 0x7f145071d600>\n\n\n\n\n\nExtracting one batch for your dataloader and see if the data is OK\n\nx = one_batch[0].permute(0,3,2,1).cpu()\n\n\ny = one_batch[1:]\n\nBecause the bounding box in the dataloader is scaled to -1 -> 1, it needs to be rescaled to 0 -> 1 for drawing by doing (bb+1)/2*Size\n\n## Bounding Box after dataloader should Rescale\nfig, axes = plt.subplots(3, 4, figsize=(16, 12))\nfor i,ax in enumerate(axes.flat):\n    show_ground_truth(ax, x[i].cpu(), ((y[0][i]+1)/2*224).cpu(), y[1][i].cpu())\nplt.tight_layout()\n\n\n\n\nEverything looks fine! We have correct bounding boxes and their corresponding classes"
  },
  {
    "objectID": "ssd_base.html#map-to-ground-truth-and-loss-function",
    "href": "ssd_base.html#map-to-ground-truth-and-loss-function",
    "title": "Object Detection - Single Shot Detector for fastai V2",
    "section": "Map to Ground-Truth and Loss function",
    "text": "Map to Ground-Truth and Loss function\nAs you might guess, There are 2 components forming the Object Detection Loss: Classification Loss (For the class) and Localization Loss (For the bounding box)\nThe idea is, for each image, we will: - Calculate the Intersection-over-Union (IoU) of each predefined Anchor Box with the Object Bounding Box. - Assign the label for each cell (Map to ground truth) according to the IoUs. Background will be assigned to Cell which overlaps with no object - Calculate the Classification Loss for all Cells - Calculate the Bounding Box Location Loss only for Cells responsible to Objects (no Background) - Take the sum of these 2 losses\n\n\n\n\n\n\nNote\n\n\n\nCurrently, we will loop for each image in a batch to calculate its loss and then sum them all. I think we might have a better way to vectorize these operations, or, calculate everything in one shot directly with a batch tensor\n\n\n\n\n\nMap to Grouth Truth\n\n\n\ndef get_y(bbox,clas):\n    \"\"\"\n    Remove the zero batching from a batch\n    \n    Because the number of object in each image are different so\n    we need to zero padding for batching \n    \"\"\"\n    bbox = bbox.view(-1,4)\n    clas = clas.view(-1,1)\n    bb_keep = ((bbox[:,2]-bbox[:,0])>0).nonzero()[:,0]\n    return TensorBase(bbox)[bb_keep],TensorBase(clas)[bb_keep]\n\n\none_batch[2][idx]\n\nTensorMultiCategory([16, 16, 16, 16, 14,  7,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n                      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n                      0,  0,  0,  0,  0,  0,  0], device='cuda:0')\n\n\n\nget_y(one_batch[1][idx], one_batch[2][idx])\n\n(TensorBBox([[ 0.0966, -1.0172,  0.4870, -0.4764],\n             [-0.3311, -1.0029,  0.0835, -0.4559],\n             [-0.3511, -1.0028,  0.0783, -0.4872],\n             [ 0.1286, -1.0201,  0.5700, -0.5041],\n             [ 0.4902,  0.1488,  1.0261,  0.9663],\n             [-0.8546, -0.6447, -0.2425, -0.2718]], device='cuda:0'),\n TensorBBox([[16],\n             [16],\n             [16],\n             [16],\n             [14],\n             [ 7]], device='cuda:0'))\n\n\nWe can see that all the zero values are removed before continuing to process\n\ndef hw2corners(ctr, hw): \n    # Function to convert BB format: (centers and dims) -> corners\n    return torch.cat([ctr-hw/2, ctr+hw/2], dim=1)\n\nThe Activations are passed to a Tanh function to rescale their values to -1 -> 1. Then they are processed to make coherent with the Grid Coordinates:\n\nThe center of each cell’s prediction stays in the cell\nThe size of each cell’s prediction can be varied from 1/2 to 3/2 cell’s size to give more flexibility\n\n\n\n\n\n\n\nTip\n\n\n\nThe bounding box activations are in [x_center, y_center, width, height] format to easily define the min/max scale to the anchor box\n\n\n\ndef actn_to_bb(actn, anchors):\n    actn_bbs = torch.tanh(actn)\n    actn_centers = (actn_bbs[:,:2]/2 * grid_sizes) + anchors[:,:2]\n    actn_hw = (actn_bbs[:,2:]/2+1) * anchors[:,2:]\n    return hw2corners(actn_centers, actn_hw)\n\n\ndef one_hot_embedding(labels, num_classes):\n    return torch.eye(num_classes)[labels].cuda()\n\n\ndef intersect(box_a, box_b):\n    \"\"\"\n    Intersect area between to bounding boxes\n    \"\"\"\n    max_xy = torch.min(box_a[:, None, 2:], box_b[None, :, 2:])\n    min_xy = torch.max(box_a[:, None, :2], box_b[None, :, :2])\n    inter = torch.clamp((max_xy - min_xy), min=0)\n    return inter[:, :, 0] * inter[:, :, 1]\n\n\ndef box_sz(b): return ((b[:, 2]-b[:, 0]) * (b[:, 3]-b[:, 1]))\n\n\ndef jaccard(box_a, box_b):\n    \"\"\"\n    Jaccard or Intersection over Union\n    \"\"\"\n    inter = intersect(box_a, box_b)\n    union = box_sz(box_a).unsqueeze(1) + box_sz(box_b).unsqueeze(0) - inter\n    return inter / union\n\nMap to Ground Truth (Visualization below). The idea is looping through all anchor boxes and calculating the overlaps with the Ground Truth bounding boxes, then assigning each Anchor Box to the corresponding class\n\ndef map_to_ground_truth(overlaps):\n    prior_overlap, prior_idx = overlaps.max(1) # 3\n    gt_overlap, gt_idx = overlaps.max(0) # 16\n    gt_overlap[prior_idx] = 1.99\n    for i,o in enumerate(prior_idx): gt_idx[o] = i\n    return gt_overlap,gt_idx\n\nFor calculating loss, we will loop through every images in a batch and calculate loss for each image (ssd_1_loss), then summing the result with ssd_loss. The Classification Loss (loss_f) currently is left empty as we will discussion it later in the next section.\n\ndef ssd_1_loss(b_c,b_bb,bbox,clas):\n    bbox,clas = get_y(bbox,clas)\n    bbox = (bbox+1)/2\n    a_ic = actn_to_bb(b_bb, anchors)\n    overlaps = jaccard(bbox.data, anchor_cnr.data)\n    gt_overlap,gt_idx = map_to_ground_truth(overlaps)\n    gt_clas = clas[gt_idx]\n    pos = gt_overlap > 0.4\n    pos_idx = torch.nonzero(pos)[:,0]\n    gt_clas[~pos] = 0  # Assign the background to idx 0\n    gt_bbox = bbox[gt_idx]\n    loc_loss = ((TensorBase(a_ic[TensorBase(pos_idx)]) - TensorBase(gt_bbox[TensorBase(pos_idx)])).abs()).mean()\n    clas_loss  = loss_f(b_c, gt_clas)\n    return loc_loss, clas_loss\n\n\nanchor_cnr = hw2corners(anchors[:,:2], anchors[:,2:]).cuda()\n\n\nShowing Map To Ground Truth\nAs mentioned earlier, Map-to-Ground-Truth is a very important step for calculating loss. We should show it to make sure everything looks fine\n\nidx = 0\nbbox = one_batch[1][idx].cuda()\nclas = one_batch[2][idx].cuda()\n\n\nbbox,clas = get_y(bbox,clas)\nbbox = (bbox+1)/2\n# a_ic = actn_to_bb(b_bb, anchors)\noverlaps = jaccard(bbox.data, anchor_cnr.data)\ngt_overlap,gt_idx = map_to_ground_truth(overlaps)\ngt_clas = clas[gt_idx]\npos = gt_overlap > 0.4\npos_idx = torch.nonzero(pos)[:,0]\ngt_clas[~pos] = 0  # Assign the background to idx 0\ngt_bbox = bbox[gt_idx]\n\n\nima = one_batch[0][idx].permute(2,1,0).cpu()\n\n\nfig, ax = plt.subplots(figsize=(7,7))\ntorch_gt(ax, ima, bbox, clas)\n\n\n\n\n\nfig, ax = plt.subplots(figsize=(7,7))\ntorch_gt(ax, ima, anchor_cnr, gt_clas)\n\n\n\n\n\nsz = 224\n\n\n\nClassificaton Loss: Binary Cross Entropy and why Focal Loss\n2 tricks can be used for Classification Loss:\n\nBinary Cross-Entropy Loss without background\nFurther improve Binary Cross-Entropy Loss with Focal Loss\n\n\nBinary Cross-Entropy\n\n\nIf we treat the Background Class as one class and ask the Model to understand what is a Background, it might be too difficult. We can translate it to a set of easier questions: Is it a Cat? Is it a Dog? … through all the classes, which is exactly what Binary Cross-Entropy does\n\n\nFocal Loss\n\n\nThe classification task in object detection is very imbalance that we have a lot of background objects (check the Match to Ground-Truth image above). If we just use Binary Cross-Entropy Loss function, it will try all efforts to improve background classification\n\n\n\n\nFocal Loss vs Binary Cross Entropy Loss\n\n\nQuote from fastai2018 course:\nThe blue line is the binary cross entropy loss. If the answer is not a motorbike, and I said “I think it’s not a motorbike and I am 60% sure” with the blue line, the loss is still about 0.5 which is pretty bad. So if we want to get our loss down, then for all these things which are actually back ground, we have to be saying “I am sure that is background”, “I am sure it’s not a motorbike, or a bus, or a person” — because if I don’t say we are sure it is not any of these things, then we still get loss.\nThat is why the motorbike example did not work. Because even when it gets to lower right corner and it wants to say “I think it’s a motorbike”, there is no payoff for it to say so. If it is wrong, it gets killed. And the vast majority of the time, it is background. Even if it is not background, it is not enough just to say “it’s not background” — you have to say which of the 20 things it is.\nSo the trick is to trying to find a different loss function that looks more like the purple line. Focal loss is literally just a scaled cross entropy loss. Now if we say “I’m .6 sure it’s not a motorbike” then the loss function will say “good for you! no worries”.\n\nclass BCE_Loss(nn.Module):\n    def __init__(self, num_classes):\n        super().__init__()\n        self.num_classes = num_classes\n\n    def forward(self, pred, targ):\n        t = one_hot_embedding(targ.squeeze(), self.num_classes)\n        t = t[:,1:] # Start from 1 to exclude the Background\n        x = pred[:,1:]\n        w = self.get_weight(x,t)\n        return F.binary_cross_entropy_with_logits(x, t, w.detach(), reduction='sum')/self.num_classes\n    \n    def get_weight(self,x,t): return None\n\n\nclass FocalLoss(BCE_Loss):\n    def get_weight(self,x,t):\n        alpha,gamma = 0.25,1\n        p = x.sigmoid()\n        pt = p*t + (1-p)*(1-t)\n        w = alpha*t + (1-alpha)*(1-t)\n        return w * (1-pt).pow(gamma)\n\nThe ssd_loss will loop through every image in a batch and accumulate loss\n\ndef ssd_loss(pred, bbox, clas):\n    lcs, lls = 0., 0.\n    W = 30\n    for b_c, b_bb, bbox, clas in zip(*pred, bbox, clas):\n        loc_loss, clas_loss = ssd_1_loss(b_c, b_bb, bbox, clas)\n        lls += loc_loss\n        lcs += clas_loss\n    return lls + lcs\n\n\nloss_f = FocalLoss(len(dls.vocab))"
  },
  {
    "objectID": "ssd_base.html#training-simple-model",
    "href": "ssd_base.html#training-simple-model",
    "title": "Object Detection - Single Shot Detector for fastai V2",
    "section": "Training Simple Model",
    "text": "Training Simple Model\n\nmodel = nn.Sequential(body, head_reg4)\n\n\nlearner = Learner(dls, model, loss_func=ssd_loss)\n\n\nlearner.fit_one_cycle(5, 1e-3)\n\n\n\n\n\n\n\n  \n    \n      epoch\n      train_loss\n      valid_loss\n      time\n    \n  \n  \n    \n      0\n      34.889286\n      28.454723\n      00:25\n    \n    \n      1\n      32.127403\n      29.533695\n      00:23\n    \n    \n      2\n      30.588394\n      26.637667\n      00:23\n    \n    \n      3\n      29.455709\n      25.630453\n      00:23\n    \n    \n      4\n      28.651590\n      25.509596\n      00:23\n    \n  \n\n\n\nThe loss decreases, and the model can learn something. Looking at the results shown below, we can see that the predictions are not so bad but not particularly good either. In the next session, we can see how to improve the results with more anchor boxes\n\nShow Results\n\none_batch = dls.valid.one_batch()\nlearner.model.eval();\npred = learner.model(one_batch[0])\nb_clas, b_bb = pred\nx = one_batch[0]\n\nfig, axes = plt.subplots(3, 4, figsize=(16, 12))\nfor idx,ax in enumerate(axes.flat):\n    ima = x.permute(0,3,2,1).cpu()[idx]\n#     ima=md.val_ds.ds.denorm(x)[idx]\n    bbox,clas = get_y(y[0][idx], y[1][idx])\n    a_ic = actn_to_bb(b_bb[idx], anchors)\n    torch_gt(ax, ima, a_ic, b_clas[idx].max(1)[1], b_clas[idx].max(1)[0].sigmoid(), 0.21)\n#plt.tight_layout()\nplt.subplots_adjust(wspace=0.15, hspace=0.15)"
  },
  {
    "objectID": "ssd_base.html#more-anchors",
    "href": "ssd_base.html#more-anchors",
    "title": "Object Detection - Single Shot Detector for fastai V2",
    "section": "More anchors",
    "text": "More anchors\nAs said earlier, the anchor box is a hint for the model to not go too far and focus on a part of the image. So obviously, 4x4 grid is not enough to predict an object of any size. In this part, by adding more Conv2d layers, we will have 3 grids: 4x4, 2x2, 1x1 and each cell will have 9 variations: 3-zooms and 3-ratios\nThe total number of anchors is: (16 + 4 + 1) x 9 = 189 anchors\n\n\n\nimage8.png\n\n\n\n# This is for release the GPU memrory while experimenting. I guess it is not enough. Please tell me if you know a better way\ndel learner\ndel model\nimport gc; gc.collect()\ntorch.cuda.empty_cache()\n\n\nanc_grids = [4,2,1]\nanc_zooms = [0.7, 1., 1.3]\nanc_ratios = [(1.,1.), (1.,0.5), (0.5,1.)]\nanchor_scales = [(anz*i,anz*j) for anz in anc_zooms for (i,j) in anc_ratios]\nk = len(anchor_scales)\nanc_offsets = [1/(o*2) for o in anc_grids]\nk\n\n9\n\n\n\nanc_x = np.concatenate([np.repeat(np.linspace(ao, 1-ao, ag), ag)\n                        for ao,ag in zip(anc_offsets,anc_grids)])\nanc_y = np.concatenate([np.tile(np.linspace(ao, 1-ao, ag), ag)\n                        for ao,ag in zip(anc_offsets,anc_grids)])\nanc_ctrs = np.repeat(np.stack([anc_x,anc_y], axis=1), k, axis=0)\n\n\nanc_x\n\narray([0.125, 0.125, 0.125, 0.125, 0.375, 0.375, 0.375, 0.375, 0.625,\n       0.625, 0.625, 0.625, 0.875, 0.875, 0.875, 0.875, 0.25 , 0.25 ,\n       0.75 , 0.75 , 0.5  ])\n\n\n\nanc_sizes  =   np.concatenate([np.array([[o/ag,p/ag] for i in range(ag*ag) for o,p in anchor_scales])\n               for ag in anc_grids])\ngrid_sizes = torch.tensor(np.concatenate([np.array([ 1/ag       for i in range(ag*ag) for o,p in anchor_scales])\n               for ag in anc_grids]), requires_grad=False).unsqueeze(1).cuda()\nanchors = torch.tensor(np.concatenate([anc_ctrs, anc_sizes], axis=1), requires_grad=False).float().cuda()\nanchor_cnr = hw2corners(anchors[:,:2], anchors[:,2:]).cuda()\n\n\nanchor_cnr.shape\n\ntorch.Size([189, 4])\n\n\nWe need to adjust the SSD head a little bit. We will add more Conv2D layer with StdConv (to create 2x2 and 1x1 grids). After each StdConv is an OutConv to handle the Classification prediction and Localization prediction\n\nclass SSD_MultiHead(nn.Module):\n    def __init__(self, k, bias):\n        super().__init__()\n        self.drop = nn.Dropout(drop)\n        self.sconv0 = StdConv(512,256, stride=1, drop=drop)\n        self.sconv1 = StdConv(256,256, drop=drop)\n        self.sconv2 = StdConv(256,256, drop=drop)\n        self.sconv3 = StdConv(256,256, drop=drop)\n        self.out0 = OutConv(k, 256, bias)\n        self.out1 = OutConv(k, 256, bias)\n        self.out2 = OutConv(k, 256, bias)\n        self.out3 = OutConv(k, 256, bias)\n\n    def forward(self, x):\n        x = self.drop(F.relu(x))\n        x = self.sconv0(x)\n        x = self.sconv1(x)\n        o1c,o1l = self.out1(x)\n        x = self.sconv2(x)\n        o2c,o2l = self.out2(x)\n        x = self.sconv3(x)\n        o3c,o3l = self.out3(x)\n        return [torch.cat([o1c,o2c,o3c], dim=1),\n                torch.cat([o1l,o2l,o3l], dim=1)]\n\n\ndrop=0.4\n\n\nhead_reg4 = SSD_MultiHead(k, -4.)\n\n\nbody = create_body(resnet34(True))\nmodel = nn.Sequential(body, head_reg4)\n\n\nlearner = Learner(dls, model, loss_func=ssd_loss)\n\n\n# learner.lr_find()\n\n\nlearner.fit_one_cycle(20, 1e-3)\n\n\n\n\n\n\n\n  \n    \n      epoch\n      train_loss\n      valid_loss\n      time\n    \n  \n  \n    \n      0\n      79.482658\n      65.257332\n      00:24\n    \n    \n      1\n      77.919846\n      64.182114\n      00:24\n    \n    \n      2\n      75.337402\n      69.358673\n      00:24\n    \n    \n      3\n      70.927734\n      73.576935\n      00:24\n    \n    \n      4\n      65.866829\n      58.502281\n      00:24\n    \n    \n      5\n      61.796001\n      51.171406\n      00:24\n    \n    \n      6\n      58.571583\n      47.785007\n      00:24\n    \n    \n      7\n      55.809723\n      45.772766\n      00:24\n    \n    \n      8\n      53.606243\n      45.726265\n      00:25\n    \n    \n      9\n      51.751816\n      45.473743\n      00:24\n    \n    \n      10\n      49.946224\n      43.707134\n      00:24\n    \n    \n      11\n      48.457012\n      42.950340\n      00:25\n    \n    \n      12\n      46.938705\n      40.909351\n      00:24\n    \n    \n      13\n      45.661766\n      40.690815\n      00:24\n    \n    \n      14\n      44.419174\n      40.372437\n      00:25\n    \n    \n      15\n      43.232628\n      39.393692\n      00:24\n    \n    \n      16\n      42.119759\n      38.884872\n      00:24\n    \n    \n      17\n      41.290310\n      38.704178\n      00:24\n    \n    \n      18\n      40.546024\n      38.666664\n      00:24\n    \n    \n      19\n      39.970467\n      38.707432\n      00:24\n    \n  \n\n\n\n\nShow results\n\none_batch = dls.valid.one_batch()\nlearner.model.eval();\npred = learner.model(one_batch[0])\nb_clas, b_bb = pred\nx = one_batch[0]\n\nfig, axes = plt.subplots(3, 4, figsize=(16, 12))\nfor idx,ax in enumerate(axes.flat):\n    ima = x.permute(0,3,2,1).cpu()[idx]\n#     ima=md.val_ds.ds.denorm(x)[idx]\n    bbox,clas = get_y(y[0][idx], y[1][idx])\n    a_ic = actn_to_bb(b_bb[idx], anchors)\n    torch_gt(ax, ima, a_ic, b_clas[idx].max(1)[1], b_clas[idx].max(1)[0].sigmoid(), thresh=0.21)\n#plt.tight_layout()\nplt.subplots_adjust(wspace=0.15, hspace=0.15)\n\n\n\n\nThe result looks better than the simple version above"
  },
  {
    "objectID": "ssd_base.html#non-maximum-suppression-nms",
    "href": "ssd_base.html#non-maximum-suppression-nms",
    "title": "Object Detection - Single Shot Detector for fastai V2",
    "section": "Non Maximum Suppression (NMS)",
    "text": "Non Maximum Suppression (NMS)\nYou can see in the previous results, that having a lot of Anchor Boxes leads to many overlaps. You can use Non Maximum Suppression, a technique to choose one bounding box out of many overlapping ones\n\ndef nms(boxes, scores, overlap=0.5, top_k=100):\n    keep = scores.new(scores.size(0)).zero_().long()\n    if boxes.numel() == 0: return keep\n    x1 = boxes[:, 0]\n    y1 = boxes[:, 1]\n    x2 = boxes[:, 2]\n    y2 = boxes[:, 3]\n    area = torch.mul(x2 - x1, y2 - y1)\n    v, idx = scores.sort(0)  # sort in ascending order\n    idx = idx[-top_k:]  # indices of the top-k largest vals\n    xx1 = boxes.new()\n    yy1 = boxes.new()\n    xx2 = boxes.new()\n    yy2 = boxes.new()\n    w = boxes.new()\n    h = boxes.new()\n\n    count = 0\n    while idx.numel() > 0:\n        i = idx[-1]  # index of current largest val\n        keep[count] = i\n        count += 1\n        if idx.size(0) == 1: break\n        idx = idx[:-1]  # remove kept element from view\n        # load bboxes of next highest vals\n        torch.index_select(x1, 0, idx, out=xx1)\n        torch.index_select(y1, 0, idx, out=yy1)\n        torch.index_select(x2, 0, idx, out=xx2)\n        torch.index_select(y2, 0, idx, out=yy2)\n        # store element-wise max with next highest score\n        xx1 = torch.clamp(xx1, min=x1[i])\n        yy1 = torch.clamp(yy1, min=y1[i])\n        xx2 = torch.clamp(xx2, max=x2[i])\n        yy2 = torch.clamp(yy2, max=y2[i])\n        w.resize_as_(xx2)\n        h.resize_as_(yy2)\n        w = xx2 - xx1\n        h = yy2 - yy1\n        # check sizes of xx1 and xx2.. after each iteration\n        w = torch.clamp(w, min=0.0)\n        h = torch.clamp(h, min=0.0)\n        inter = w*h\n        # IoU = i / (area(a) + area(b) - i)\n        rem_areas = torch.index_select(area, 0, idx)  # load remaining areas)\n        union = (rem_areas - inter) + area[i]\n        IoU = inter/union  # store result in iou\n        # keep only elements with an IoU <= overlap\n        idx = idx[IoU.le(overlap)]\n    return keep, count\n\n\ndef show_nmf(idx):\n    ima = one_batch[0][idx].permute(2,1,0).cpu()\n    bbox = one_batch[1][idx].cuda()\n    clas = one_batch[2][idx].cuda()\n    bbox,clas = get_y(bbox,clas)\n    \n    a_ic = actn_to_bb(b_bb[idx], anchors)\n    clas_pr, clas_ids = b_clas[idx].max(1)\n    clas_pr = clas_pr.sigmoid()\n\n    conf_scores = b_clas[idx].sigmoid().t().data\n\n    out1,out2,cc = [],[],[]\n    for cl in range(1, len(conf_scores)):\n        c_mask = conf_scores[cl] > 0.25\n        if c_mask.sum() == 0: continue\n        scores = conf_scores[cl][c_mask]\n        l_mask = c_mask.unsqueeze(1).expand_as(a_ic)\n        boxes = a_ic[l_mask].view(-1, 4)\n        ids, count = nms(boxes.data, scores, 0.4, 50)\n        ids = ids[:count]\n        out1.append(scores[ids])\n        out2.append(boxes.data[ids])\n        cc.append([cl]*count)\n    if not cc:\n        print(f\"{i}: empty array\")\n        return\n    cc = torch.tensor(np.concatenate(cc))\n    out1 = torch.cat(out1)\n    out2 = torch.cat(out2)\n\n    fig, ax = plt.subplots(figsize=(8,8))\n    torch_gt(ax, ima, out2, cc, out1, 0.1)\n\n\nfor i in range(25, 35): show_nmf(i)\n\n25: empty array\n28: empty array\n31: empty array\n32: empty array"
  }
]